#!/usr/bin/env python2.7
"""
count-kmers: Create a Markov chain model from FASTA sequences.

The FASTA file to be used to train the model is read from the file specified by
the --in option, defaulting to standard input. Each sequence in the FASTA file 
is regarded as an example training string for the model. 

The completed model is printed to the file specified by the --out option, 
defaulting to standard output, with each observed k-mer and its corresponding 
count on a line, sorted alphabedically and separated by a single space.

The order of the Markov model is specified by the --order/-o option, which is an
integer. An order-k Markov chain model counts k+1-mers.

The alphabet to be accepted is specified by the --alphabet/-a option, as a list 
of acceptable characters. Characters in the sequence that are not listed in the 
alphabet will be ignored. Note that all characters read from the sequence are 
converted to upper-case, so lower-case characters in the alphabet are 
meaningless.

Written for BME 205 Fall 2012
By Adam Novak <anovak1@ucsc.edu>
Re-uses sample code and documentation from 
<http://users.soe.ucsc.edu/~karplus/bme205/f12/Scaffold.html>
"""

# Imports!
import argparse, collections, re, sys

import fast, markov

def parse_args(args):
    """
    Takes in the command-line arguments list (args), and returns a nice argparse
    result with fields for all the options.
    Borrows heavily from the argparse documentation examples:
    <http://docs.python.org/library/argparse.html>
    """
    
    # The command line arguments start with the program name, which we don't
    # want to treat as an argument for argparse. So we remove it.
    args = args[1:]
    
    # Construct the parser (which is stored in parser)
    # Module docstring lives in __doc__
    # See http://python-forum.com/pythonforum/viewtopic.php?f=3&t=36847
    # And a formatter class so our examples in the docstring look good. Isn't it
    # convenient how we already wrapped it to 80 characters?
    # See http://docs.python.org/library/argparse.html#formatter-class
    parser = argparse.ArgumentParser(description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    
    # Now add all the options to it
    # Options are magically managing file input with default streams.
    # See http://docs.python.org/library/argparse.html#nargs
    # --in and --out options aren't in the spec, but the default behavior is 
    # unchanged, so we have them.
    parser.add_argument("--in", dest="inFile", type=argparse.FileType('r'), 
        default=sys.stdin, 
        help="FASTA file to read (defaults to standard input)")
    parser.add_argument("--out", dest="outFile", type=argparse.FileType('w'), 
        default=sys.stdout, 
        help="model file to write (defaults to standard output)")                   
    parser.add_argument("--order", "-o", dest="order", type=int, default=0, 
        help="Markov chain order (default 0)")
    parser.add_argument("--alphabet", "-a", dest="alphabet", type=str,
        default="ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        help="acceptable alphabet (default: all letters)")
    
    
    # Invoke the parser
    return parser.parse_args(args)
    
def main(args):
    """
    Parses command line arguments and creates and outputs a Markov chain model.
    "args" specifies the program arguments, with args[0] being the executable
    name. The return value should be used as the program's exit code.
    """
    
    options = parse_args(args) # This holds the nicely-parsed options object
    
    # model holds the Markov chain model we generate
    model = markov.MarkovModel(options.order, options.alphabet)
    
    # For each sequence (in sequence), train on its letters.
    # Letters is a list of 1-character strings, but luckily our Markov model is
    # general enough to account for this.
    # Specify an alphabet regex including J to the FASTA parser
    # Since turning a character set into a regex requires escaping things like 
    # -, we'll do more restrictive filtering ourselves.
    for sequence in fast.read_fasta(options.inFile, alphabet="[A-Za-z\-*]"):
        # Give it to the model.
        model.train(sequence.letters)
      
    # Print the model
    model.write(options.outFile)  
        
    

if __name__ == "__main__" :
    # No error catching because stack traces are important
    # And I don't want to mess around with a module to get them
    sys.exit(main(sys.argv)) 
