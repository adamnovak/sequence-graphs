#!/usr/bin/env python2.7
"""
coding-cost: compute the encoding costs of sequences under a Markov model.

The model file to be used is read from the file specified by the --in option, 
defaulting to standard input.

The FASTA file to analyze is specified as a positional command-line argument.

The order of the Markov model is auto-detected from the model data.

The alphabet to be accepted is specified by the --alphabet/-a option, as a list 
of acceptable characters. Characters in the sequence that are not listed in the 
alphabet will be ignored. Note that all characters read from the sequence are 
converted to upper-case, so lower-case characters in the alphabet are 
meaningless. Kmers in the model data that include characters not in the alphabet
(excluding the start/stop character) are removed from the model. Characters in 
the FASTA sequences that are not in the alphabet are stripped before encoding 
cost is calculated.

A report on the collective encoding cost per character of all sequences in the 
FASTA file is printed to standard output. The "collective" encoding cost per 
character is the total encoding cost for all strings, divided by the total 
encoded length of all strings. Characters filtered out of the string due to not 
being in the alphabet do not count.

Pseudocounts can be requested via the --pseudocount option. By default, a
pseudocount of 1 is used.

Written for BME 205 Fall 2012
By Adam Novak <anovak1@ucsc.edu>
Re-uses sample code and documentation from 
<http://users.soe.ucsc.edu/~karplus/bme205/f12/Scaffold.html>
"""

# Imports!
import argparse, collections, re, sys

import fast, markov

def parse_args(args):
    """
    Takes in the command-line arguments list (args), and returns a nice argparse
    result with fields for all the options.
    Borrows heavily from the argparse documentation examples:
    <http://docs.python.org/library/argparse.html>
    """
    
    # The command line arguments start with the program name, which we don't
    # want to treat as an argument for argparse. So we remove it.
    args = args[1:]
    
    # Construct the parser (which is stored in parser)
    # Module docstring lives in __doc__
    # See http://python-forum.com/pythonforum/viewtopic.php?f=3&t=36847
    # And a formatter class so our examples in the docstring look good. Isn't it
    # convenient how we already wrapped it to 80 characters?
    # See http://docs.python.org/library/argparse.html#formatter-class
    parser = argparse.ArgumentParser(description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    
    # Now add all the options to it
    # Options are magically managing file input with default streams.
    # See http://docs.python.org/library/argparse.html#nargs
    # --in and --out options aren't in the spec, but the default behavior is 
    # unchanged, so we have them.
    parser.add_argument("--in", dest="inFile", type=argparse.FileType('r'), 
        default=sys.stdin, 
        help="model file to read (defaults to standard input)")
    parser.add_argument("fastaFile", type=argparse.FileType('r'),
        help="FASTA file to read (required)")                   
    parser.add_argument("--alphabet", "-a", dest="alphabet", type=str,
        default="ABCDEFGHIJKLMNOPQRSTUVWXYZ",
        help="encoding alphabet (default: all letters)")
    parser.add_argument("--pseudocount", "-p", type=float, dest="pseudocount", 
        default=1.0, help="add a pseudocount")
    parser.add_argument("--debug", action="store_true", 
        help="print debugging information")

    # Invoke the parser
    return parser.parse_args(args)
    
def main(args):
    """
    Parses command line arguments and outputs encoding costs.
    "args" specifies the program arguments, with args[0] being the executable
    name. The return value should be used as the program's exit code.
    """
    
    options = parse_args(args) # This holds the nicely-parsed options object
    
    # alphabet holds a set of all legal alphabet characters
    alphabet = set(options.alphabet)
    
    # model holds the Markov chain model we read
    model = markov.MarkovModel.read(options.inFile, options.alphabet)
    
    if options.pseudocount > 0:
        print "Adding pseudocount of {}...".format(options.pseudocount)
        model.set_pseudocount(options.pseudocount)
    else:
        print "WARNING: Pseudocounts not in use."
        print "Unobserved kmers will have infinite cost!"
        
    print "Computing model probabilities..."
    model.compute_probabilities()
    
    print "Processing sequences..."
    
    # This holds the running total encoding cost for all sequences, as a float
    total_cost = 0.0
    
    # And this holds the total (encoded) length of all sequences processed
    total_length = 0
    
    # And this is the total number of sequences
    total_sequences = 0
    
    # For each sequence (in sequence), train on its letters.
    # Letters is a list of 1-character strings, but luckily our Markov model is
    # general enough to account for this.
    # Specify an alphabet regex including J to the FASTA parser
    # Since turning a character set into a regex requires escaping things like 
    # -, we'll do more restrictive filtering ourselves.
    for sequence in fast.read_fasta(options.fastaFile, alphabet="[A-Za-z\-*]"):
        # sequence_cost holds the encoding cost for the sequence
        # sequence_length holds the number of encoded characters in the 
        # sequence, ignoring those not in the alphabet and counting the stop 
        # character at the end as an encoded character.
        (sequence_cost, sequence_length) = model.encoding_cost(sequence.letters)
        
        # Report some debug info
        if options.debug:
            print "Sequence {} costs {} bits.".format(sequence.identifier, 
                sequence_cost)
            
        # Add to the totals
        total_cost += sequence_cost
        total_length += sequence_length - 1 # Don't count terminating stop
        total_sequences += 1
    
    # Print the report
    print "{} total characters processed, costing {} total bits.".format(
        total_length, total_cost)    
    if total_length > 0:
        print "Encoding cost per character: {} bits/character".format(
            float(total_cost) / float(total_length))
    if total_sequences > 0:
        print "Encoding cost per sequence: {} bits/sequence".format(
            float(total_cost) / float(total_sequences))
    
        
if __name__ == "__main__" :
    # No error catching because stack traces are important
    # And I don't want to mess around with a module to get them
    sys.exit(main(sys.argv)) 
