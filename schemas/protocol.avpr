@namespace("edu.ucsc.soe.sequence-graph")
protocol SequenceGraph {
    
    // The schemas here describe a Sequence Graph. In the graph, Sides 
    // are nodes, linked by SequenceGraphEdges, which may be AlleleGroups or 
    // Adjacencies.
    
    // We also have Loci with IDs, which may be either Sites (containing
    // AlleleGroups) or Breakpoints (containing Adjacencies); SequenceGraphEdges 
    // can be joined against the Loci to see what Site or Breakpoint each
    // AlleleGroup or Adjacency to, or to find the SequenceGraphEdges in a set
    // of Sites or Breakpoints.
    
    // First, some basic structures to avoid repeating ourselves.
    
    record Region {
        // Identifies a genomic region. Fields should not be null unless you are
        // doing a projection.
        
        // What contig is it on? "chr1", "chr2", "chrM", etc. "novel" is used 
        // for novel insertions.
        union { null, string } = null;
        // Where does the region start (inclusive)?
        union { null, int } start = null;
        // Where does the region end (exclusive)?
        union { null, int } end = null; 
    }
    
    record PloidyBounds {
        // Upper and lower bounds on ploidy.
        
        // A lower bound on the ploidy. null means the lower bound is 1.
        union { null, int } lower = null;
        // An upper bound on the ploidy. null means the upper bound is the same
        // as the lower bound.
        union { null, int } upper = null;
    }
    
    // Parts of the sequence graph: Sides and SequenceGraphEdges and the
    // AlleleGroups and Adjacencies they contain
    
    record Side {
        // Represents an AlleleGroup side, a node in the graph where
        // AlleleGroups and Adjacencies are edges.
        
        // A unique ID for the Side
        union { null, string } id = null;
        
        // What Genome does this belong to?
        union { null, string } genome = null;
    }
    
    record AlleleGroup {
        // AVRO schema for an AlleleGroup. AlleleGroups are contained within
        // SequenceGraphEdges, which specify the Sides they link.
        
        // The sequence string, or null for an AlleleGroup that maches the
        // reference.
        union { null, string } sequence = null;
    }
    
    record Adjacency {
        // AVRO schema for an Adjacency. Fields should not be null unless you
        // are doing a projection. Adjacencies are contained within
        // SequenceGraphEdges, which specify the Sides they link.
        
        // TODO: Do Adjacencies really need anything in them that isn't shared
        // with AlleleGroups?
    }
    
    record SequenceGraphEdge {
        // An edge in the Sequence Graph, representing either an Adjaceny or an
        // AlleleGroup. Fields should not be null unless you are doing a 
        // projection. We want to use one type here instead of two so that our
        // graph only has one type in its edge RDD.
        
        // A unique ID for the edge, used when it is referenced in the
        // annotation raph as a node.
        union { null, string } id = null;
        // The ID of the first (5') Side
        union { null, string } left = null;
        // The ID of the second (3') Side
        union { null, string } right = null;
        
        // The ID of the locus (site or breakpoint) where this Adjacency or 
        // AlleleGroup lives.
        union { null, string } locus = null;
        
        // The ploidy bounds on this Adjacency or AlleleGroup
        union { null, PloidyBounds } ploidy = null;
        
        // What Genome does this belong to?
        union { null, string } genome = null;
        
        // The Adjacency or AlleleGroup itself
        union { null, AlleleGroup, Adjacency } contents = null;
    }
    
    // Now Sites and Breakpoints and Loci to hold them.
    
    record Site {
        // Represents a Site which AlleleGroups can occupy. Fields should not be
        // null unless you are doing a projection. Stored in a Locus, which
        // provides a unique ID.
        
        // Where is the site?
        union { null, Region } region = null;
        
        // What reference is it defined on?
        union { null, string } reference = null;
        
    }
    
    record Breakpoint {
        // Represents a Breakpoint between two Sites; Adjacencies can occupy it.
        // Stored in a Locus, which provides a unique ID.
        
        // TODO: do we want a graph of Sites and Breakpoints?
        
    }
    
    record Locus {
        // Represents a Site or Breakpoint. A bunch of these can be joined
        // against a bunch of SequenceGraphEdges to get the Site or Breakpoint
        // for each AlleleGroup or Adjacency.
        
        // A unique ID
        union { null, string } id = null;
        
        // The Site or Breakpoint we represent
        union { null, Site, Breakpoint } = null;
        
    }
    
    // Annotations: keyed by site, genome, or (site, genome) together. Can be
    // joined against to get annotation information for sites, genomes, or
    // specific sites in specific genomes.
    
    // TODO: Should these be made part of the things they annotate instead?
    
    record SiteAnnotation {
        // Holds metadata for a (variant) Site. Nobody annotates fixed Sites.
        
        // What Site locus are we annotating?
        union { null, string } site = null;
        
        // Annotations

        // fields denote whether variant has been seen in dbSNP, Hapmap2/3, or
        // 1000 genomes
        union { boolean, null } inDbSNP = false;
        union { boolean, null } inHM2 = false;
        union { boolean, null } inHM3 = false;
        union { boolean, null } in1000G = false;
    }

    record SampleAnnotation {
        // Holds metadata for a Sample
        
        // What sample are we annotating?
        union { null, string } sample = null;
        
        // Annotations

        // record group identifer from sequencing run
        union { null, string } recordGroupSequencingCenter = null;
        union { null, string } recordGroupDescription = null;
        union { null, long } recordGroupRunDateEpoch = null;
        union { null, string } recordGroupFlowOrder = null;
        union { null, string } recordGroupKeySequence = null;
        union { null, string } recordGroupLibrary = null;
        union { null, int } recordGroupPredictedMedianInsertSize = null;
        union { null, string } recordGroupPlatform = null;
        union { null, string } recordGroupPlatformUnit = null;
        union { null, string } recordGroupSample = null;

    }
    
    record GenomeAnnotation {
        // Annotation for a genome, many of which may exist in a Sample.
    
        // What genome are we annotating?
        union { null, string } genome = null;
        
        // What sample is it in?
        union { null, string } sample = null;
        
        // identifiers for genome cohort and genome ethnicity
        union { null, string } genomeEthnicity = null;
        union { null, string } genomeCohort = null;
        
        
    }    
    
    record SiteGenomeAnnotation {
        // Annotation for a certain Site in a certain Genome. Based on
        // ADAMGenotype.
        
        // What Site does this belong to (Locus ID)?
        union { null, string } site = null;
        
        // What Genome does this belong to?
        union { null, string } genome = null;
        
        // Annotations

        // expected value of number of chromosomes with this allele at this 
        // site.
        union { null, double } expectedAlleleDosage = null;
        // coverage at genotype site
        union { null, int } depth = null;
        // RMS base quality score for reads aligned to genotyped site
        union { null, int } rmsBaseQuality = null;
        // RMS mapping quality for reads aligned to genotyped site
        union { null, int } rmsMappingQuality = null;
        // number of reads mapped at site on forward strand
        union { null, int } readsMappedForwardStrand = null;
        // number of reads mapped with mapq = 0
        union { null, int } readsMappedMapQ0 = null;
    }
}
