package edu.ucsc.genome

import scala.math._

/**
 * Provides a "pen" that can be used to "draw" Sequence Graph elements (Sides,
 * AlleleGroups, Adjacencies, and Anchors).
 *
 * Exists mostly as a workaround for the fact that the Sequence Graph object
 * constructors as generated by Avro are awkward: if you want to do anything
 * other than specify all the fields, you need to instantiate a new Builder just
 * to build your object, and everything that needs a unique ID demands that you
 * provide it with one.
 *
 * We want to replace this:
 * {{{
 * // Make the Anchor
 * val anchor = new Anchor(
 *     new Edge(nextID, startSide.id, endSide.id), 
 *     new PloidyBounds(1, null, null), 
 *     sample)
 * nextID += 1
 * }}}
 * with this:
 * {{{
 * pen.drawAnchor(startSide, endSide)
 * }}}
 *
 * We have some implicit conversions in the package (like Side to its Long ID)
 * that make this a bit easier.
 *
 * The pen, when constructed, takes the genome name it is drawing for, the base
 * ID to start at, and the number of IDs it is allowed to generate (before
 * infringing on some other parallel task's ID space). All of these are
 * optional.
 *
 */
class SequenceGraphPen(genome: String = "", idStart: Long = 0, 
    idCount: Long = -1) {

    // Keep around a source of IDs.
    val source = new IDSource(idStart, idCount)
    
    /**
     * Produce a new Side on the given contig, with the given base and face.
     * Optionally can flag the Side as reference; by default it is not.
     */
    def drawSide(contig: String, base: Long, face: Face,
        isReference: Boolean = false): Side = {
        // Where is the Side in the reference coordinate system?
        val position = new Position(contig, base, face)
        // Say that this Side appears there, and that its lower bound is also
        // that position. We could also have Sides in complicated insert graphs
        // that have just UUID positions, but they still have a lower bound in
        // our linear coordinate system.
        new Side(source.id, position, isReference, position)
    }
    
    /**
     * Make a new Edge between the Sides with the given IDs. This is not the
     * same as adjacencies; drawAdjacency draws those.
     */
    def drawEdge(left: Long, right: Long): Edge = new Edge(source.id, left,
        right)
    
    /**
     * Make a new AlleleGroup between the given pair of Side IDs, carrying the
     * given Allele and using the given PloidyBounds (which defaults to a
     * constant ploidy of 1).
     */
    def drawAlleleGroup(left: Long, right: Long, allele: Allele, 
        ploidy: PloidyBounds = 1): AlleleGroup = {
        
        new AlleleGroup(drawEdge(left, right), allele, ploidy, genome)
    }
    
    /**
     * Make a new Adjacency between the given Sides, with the given ploidy
     * bounds (defaulting to a constant 1).
     */
    def drawAdjacency(left: Long, right: Long, 
        ploidy: PloidyBounds = 1): Adjacency = {
        
        new Adjacency(drawEdge(left, right), ploidy, genome)
    }
    
    /**
     * Makes a new Anchor between the given Sides, with the given ploidy bounds
     * (defaulting to a constant 1).
     */
    def drawAnchor(left: Long, right: Long, 
        ploidy: PloidyBounds = 1): Anchor = {
        
        new Anchor(drawEdge(left, right), ploidy, genome)
    }
    
    
}

